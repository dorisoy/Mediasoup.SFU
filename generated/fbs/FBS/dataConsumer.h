// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_DATACONSUMER_FBS_DATACONSUMER_H_
#define FLATBUFFERS_GENERATED_DATACONSUMER_FBS_DATACONSUMER_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 24 &&
              FLATBUFFERS_VERSION_MINOR == 3 &&
              FLATBUFFERS_VERSION_REVISION == 6,
             "Non-compatible flatbuffers version included");

#include "common.h"
#include "dataProducer.h"
#include "sctpParameters.h"

namespace FBS {
namespace DataConsumer {

struct GetBufferedAmountResponse;
struct GetBufferedAmountResponseBuilder;

struct SetBufferedAmountLowThresholdRequest;
struct SetBufferedAmountLowThresholdRequestBuilder;

struct DumpResponse;
struct DumpResponseBuilder;

struct GetStatsResponse;
struct GetStatsResponseBuilder;

struct SendRequest;
struct SendRequestBuilder;

struct SetSubchannelsRequest;
struct SetSubchannelsRequestBuilder;

struct SetSubchannelsResponse;
struct SetSubchannelsResponseBuilder;

struct AddSubchannelRequest;
struct AddSubchannelRequestBuilder;

struct AddSubchannelResponse;
struct AddSubchannelResponseBuilder;

struct RemoveSubchannelRequest;
struct RemoveSubchannelRequestBuilder;

struct RemoveSubchannelResponse;
struct RemoveSubchannelResponseBuilder;

struct BufferedAmountLowNotification;
struct BufferedAmountLowNotificationBuilder;

struct MessageNotification;
struct MessageNotificationBuilder;

inline const ::flatbuffers::TypeTable *GetBufferedAmountResponseTypeTable();

inline const ::flatbuffers::TypeTable *SetBufferedAmountLowThresholdRequestTypeTable();

inline const ::flatbuffers::TypeTable *DumpResponseTypeTable();

inline const ::flatbuffers::TypeTable *GetStatsResponseTypeTable();

inline const ::flatbuffers::TypeTable *SendRequestTypeTable();

inline const ::flatbuffers::TypeTable *SetSubchannelsRequestTypeTable();

inline const ::flatbuffers::TypeTable *SetSubchannelsResponseTypeTable();

inline const ::flatbuffers::TypeTable *AddSubchannelRequestTypeTable();

inline const ::flatbuffers::TypeTable *AddSubchannelResponseTypeTable();

inline const ::flatbuffers::TypeTable *RemoveSubchannelRequestTypeTable();

inline const ::flatbuffers::TypeTable *RemoveSubchannelResponseTypeTable();

inline const ::flatbuffers::TypeTable *BufferedAmountLowNotificationTypeTable();

inline const ::flatbuffers::TypeTable *MessageNotificationTypeTable();

struct GetBufferedAmountResponse FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef GetBufferedAmountResponseBuilder Builder;
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return GetBufferedAmountResponseTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_BUFFEREDAMOUNT = 4
  };
  uint32_t bufferedAmount() const {
    return GetField<uint32_t>(VT_BUFFEREDAMOUNT, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_BUFFEREDAMOUNT, 4) &&
           verifier.EndTable();
  }
};

struct GetBufferedAmountResponseBuilder {
  typedef GetBufferedAmountResponse Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_bufferedAmount(uint32_t bufferedAmount) {
    fbb_.AddElement<uint32_t>(GetBufferedAmountResponse::VT_BUFFEREDAMOUNT, bufferedAmount, 0);
  }
  explicit GetBufferedAmountResponseBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<GetBufferedAmountResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<GetBufferedAmountResponse>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<GetBufferedAmountResponse> CreateGetBufferedAmountResponse(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t bufferedAmount = 0) {
  GetBufferedAmountResponseBuilder builder_(_fbb);
  builder_.add_bufferedAmount(bufferedAmount);
  return builder_.Finish();
}

struct SetBufferedAmountLowThresholdRequest FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SetBufferedAmountLowThresholdRequestBuilder Builder;
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return SetBufferedAmountLowThresholdRequestTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_THRESHOLD = 4
  };
  uint32_t threshold() const {
    return GetField<uint32_t>(VT_THRESHOLD, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_THRESHOLD, 4) &&
           verifier.EndTable();
  }
};

struct SetBufferedAmountLowThresholdRequestBuilder {
  typedef SetBufferedAmountLowThresholdRequest Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_threshold(uint32_t threshold) {
    fbb_.AddElement<uint32_t>(SetBufferedAmountLowThresholdRequest::VT_THRESHOLD, threshold, 0);
  }
  explicit SetBufferedAmountLowThresholdRequestBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<SetBufferedAmountLowThresholdRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<SetBufferedAmountLowThresholdRequest>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<SetBufferedAmountLowThresholdRequest> CreateSetBufferedAmountLowThresholdRequest(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t threshold = 0) {
  SetBufferedAmountLowThresholdRequestBuilder builder_(_fbb);
  builder_.add_threshold(threshold);
  return builder_.Finish();
}

struct DumpResponse FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef DumpResponseBuilder Builder;
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return DumpResponseTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_DATAPRODUCERID = 6,
    VT_TYPE = 8,
    VT_SCTPSTREAMPARAMETERS = 10,
    VT_LABEL = 12,
    VT_PROTOCOL = 14,
    VT_BUFFEREDAMOUNTLOWTHRESHOLD = 16,
    VT_PAUSED = 18,
    VT_DATAPRODUCERPAUSED = 20,
    VT_SUBCHANNELS = 22
  };
  const ::flatbuffers::String *id() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ID);
  }
  const ::flatbuffers::String *dataProducerId() const {
    return GetPointer<const ::flatbuffers::String *>(VT_DATAPRODUCERID);
  }
  FBS::DataProducer::Type type() const {
    return static_cast<FBS::DataProducer::Type>(GetField<uint8_t>(VT_TYPE, 0));
  }
  const FBS::SctpParameters::SctpStreamParameters *sctpStreamParameters() const {
    return GetPointer<const FBS::SctpParameters::SctpStreamParameters *>(VT_SCTPSTREAMPARAMETERS);
  }
  const ::flatbuffers::String *label() const {
    return GetPointer<const ::flatbuffers::String *>(VT_LABEL);
  }
  const ::flatbuffers::String *protocol() const {
    return GetPointer<const ::flatbuffers::String *>(VT_PROTOCOL);
  }
  uint32_t bufferedAmountLowThreshold() const {
    return GetField<uint32_t>(VT_BUFFEREDAMOUNTLOWTHRESHOLD, 0);
  }
  bool paused() const {
    return GetField<uint8_t>(VT_PAUSED, 0) != 0;
  }
  bool dataProducerPaused() const {
    return GetField<uint8_t>(VT_DATAPRODUCERPAUSED, 0) != 0;
  }
  const ::flatbuffers::Vector<uint16_t> *subchannels() const {
    return GetPointer<const ::flatbuffers::Vector<uint16_t> *>(VT_SUBCHANNELS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_ID) &&
           verifier.VerifyString(id()) &&
           VerifyOffsetRequired(verifier, VT_DATAPRODUCERID) &&
           verifier.VerifyString(dataProducerId()) &&
           VerifyField<uint8_t>(verifier, VT_TYPE, 1) &&
           VerifyOffset(verifier, VT_SCTPSTREAMPARAMETERS) &&
           verifier.VerifyTable(sctpStreamParameters()) &&
           VerifyOffsetRequired(verifier, VT_LABEL) &&
           verifier.VerifyString(label()) &&
           VerifyOffsetRequired(verifier, VT_PROTOCOL) &&
           verifier.VerifyString(protocol()) &&
           VerifyField<uint32_t>(verifier, VT_BUFFEREDAMOUNTLOWTHRESHOLD, 4) &&
           VerifyField<uint8_t>(verifier, VT_PAUSED, 1) &&
           VerifyField<uint8_t>(verifier, VT_DATAPRODUCERPAUSED, 1) &&
           VerifyOffsetRequired(verifier, VT_SUBCHANNELS) &&
           verifier.VerifyVector(subchannels()) &&
           verifier.EndTable();
  }
};

struct DumpResponseBuilder {
  typedef DumpResponse Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_id(::flatbuffers::Offset<::flatbuffers::String> id) {
    fbb_.AddOffset(DumpResponse::VT_ID, id);
  }
  void add_dataProducerId(::flatbuffers::Offset<::flatbuffers::String> dataProducerId) {
    fbb_.AddOffset(DumpResponse::VT_DATAPRODUCERID, dataProducerId);
  }
  void add_type(FBS::DataProducer::Type type) {
    fbb_.AddElement<uint8_t>(DumpResponse::VT_TYPE, static_cast<uint8_t>(type), 0);
  }
  void add_sctpStreamParameters(::flatbuffers::Offset<FBS::SctpParameters::SctpStreamParameters> sctpStreamParameters) {
    fbb_.AddOffset(DumpResponse::VT_SCTPSTREAMPARAMETERS, sctpStreamParameters);
  }
  void add_label(::flatbuffers::Offset<::flatbuffers::String> label) {
    fbb_.AddOffset(DumpResponse::VT_LABEL, label);
  }
  void add_protocol(::flatbuffers::Offset<::flatbuffers::String> protocol) {
    fbb_.AddOffset(DumpResponse::VT_PROTOCOL, protocol);
  }
  void add_bufferedAmountLowThreshold(uint32_t bufferedAmountLowThreshold) {
    fbb_.AddElement<uint32_t>(DumpResponse::VT_BUFFEREDAMOUNTLOWTHRESHOLD, bufferedAmountLowThreshold, 0);
  }
  void add_paused(bool paused) {
    fbb_.AddElement<uint8_t>(DumpResponse::VT_PAUSED, static_cast<uint8_t>(paused), 0);
  }
  void add_dataProducerPaused(bool dataProducerPaused) {
    fbb_.AddElement<uint8_t>(DumpResponse::VT_DATAPRODUCERPAUSED, static_cast<uint8_t>(dataProducerPaused), 0);
  }
  void add_subchannels(::flatbuffers::Offset<::flatbuffers::Vector<uint16_t>> subchannels) {
    fbb_.AddOffset(DumpResponse::VT_SUBCHANNELS, subchannels);
  }
  explicit DumpResponseBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<DumpResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<DumpResponse>(end);
    fbb_.Required(o, DumpResponse::VT_ID);
    fbb_.Required(o, DumpResponse::VT_DATAPRODUCERID);
    fbb_.Required(o, DumpResponse::VT_LABEL);
    fbb_.Required(o, DumpResponse::VT_PROTOCOL);
    fbb_.Required(o, DumpResponse::VT_SUBCHANNELS);
    return o;
  }
};

inline ::flatbuffers::Offset<DumpResponse> CreateDumpResponse(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> id = 0,
    ::flatbuffers::Offset<::flatbuffers::String> dataProducerId = 0,
    FBS::DataProducer::Type type = FBS::DataProducer::Type::SCTP,
    ::flatbuffers::Offset<FBS::SctpParameters::SctpStreamParameters> sctpStreamParameters = 0,
    ::flatbuffers::Offset<::flatbuffers::String> label = 0,
    ::flatbuffers::Offset<::flatbuffers::String> protocol = 0,
    uint32_t bufferedAmountLowThreshold = 0,
    bool paused = false,
    bool dataProducerPaused = false,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint16_t>> subchannels = 0) {
  DumpResponseBuilder builder_(_fbb);
  builder_.add_subchannels(subchannels);
  builder_.add_bufferedAmountLowThreshold(bufferedAmountLowThreshold);
  builder_.add_protocol(protocol);
  builder_.add_label(label);
  builder_.add_sctpStreamParameters(sctpStreamParameters);
  builder_.add_dataProducerId(dataProducerId);
  builder_.add_id(id);
  builder_.add_dataProducerPaused(dataProducerPaused);
  builder_.add_paused(paused);
  builder_.add_type(type);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<DumpResponse> CreateDumpResponseDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *id = nullptr,
    const char *dataProducerId = nullptr,
    FBS::DataProducer::Type type = FBS::DataProducer::Type::SCTP,
    ::flatbuffers::Offset<FBS::SctpParameters::SctpStreamParameters> sctpStreamParameters = 0,
    const char *label = nullptr,
    const char *protocol = nullptr,
    uint32_t bufferedAmountLowThreshold = 0,
    bool paused = false,
    bool dataProducerPaused = false,
    const std::vector<uint16_t> *subchannels = nullptr) {
  auto id__ = id ? _fbb.CreateString(id) : 0;
  auto dataProducerId__ = dataProducerId ? _fbb.CreateString(dataProducerId) : 0;
  auto label__ = label ? _fbb.CreateString(label) : 0;
  auto protocol__ = protocol ? _fbb.CreateString(protocol) : 0;
  auto subchannels__ = subchannels ? _fbb.CreateVector<uint16_t>(*subchannels) : 0;
  return FBS::DataConsumer::CreateDumpResponse(
      _fbb,
      id__,
      dataProducerId__,
      type,
      sctpStreamParameters,
      label__,
      protocol__,
      bufferedAmountLowThreshold,
      paused,
      dataProducerPaused,
      subchannels__);
}

struct GetStatsResponse FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef GetStatsResponseBuilder Builder;
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return GetStatsResponseTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TIMESTAMP = 4,
    VT_LABEL = 6,
    VT_PROTOCOL = 8,
    VT_MESSAGESSENT = 10,
    VT_BYTESSENT = 12,
    VT_BUFFEREDAMOUNT = 14
  };
  uint64_t timestamp() const {
    return GetField<uint64_t>(VT_TIMESTAMP, 0);
  }
  const ::flatbuffers::String *label() const {
    return GetPointer<const ::flatbuffers::String *>(VT_LABEL);
  }
  const ::flatbuffers::String *protocol() const {
    return GetPointer<const ::flatbuffers::String *>(VT_PROTOCOL);
  }
  uint64_t messagesSent() const {
    return GetField<uint64_t>(VT_MESSAGESSENT, 0);
  }
  uint64_t bytesSent() const {
    return GetField<uint64_t>(VT_BYTESSENT, 0);
  }
  uint32_t bufferedAmount() const {
    return GetField<uint32_t>(VT_BUFFEREDAMOUNT, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_TIMESTAMP, 8) &&
           VerifyOffsetRequired(verifier, VT_LABEL) &&
           verifier.VerifyString(label()) &&
           VerifyOffsetRequired(verifier, VT_PROTOCOL) &&
           verifier.VerifyString(protocol()) &&
           VerifyField<uint64_t>(verifier, VT_MESSAGESSENT, 8) &&
           VerifyField<uint64_t>(verifier, VT_BYTESSENT, 8) &&
           VerifyField<uint32_t>(verifier, VT_BUFFEREDAMOUNT, 4) &&
           verifier.EndTable();
  }
};

struct GetStatsResponseBuilder {
  typedef GetStatsResponse Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_timestamp(uint64_t timestamp) {
    fbb_.AddElement<uint64_t>(GetStatsResponse::VT_TIMESTAMP, timestamp, 0);
  }
  void add_label(::flatbuffers::Offset<::flatbuffers::String> label) {
    fbb_.AddOffset(GetStatsResponse::VT_LABEL, label);
  }
  void add_protocol(::flatbuffers::Offset<::flatbuffers::String> protocol) {
    fbb_.AddOffset(GetStatsResponse::VT_PROTOCOL, protocol);
  }
  void add_messagesSent(uint64_t messagesSent) {
    fbb_.AddElement<uint64_t>(GetStatsResponse::VT_MESSAGESSENT, messagesSent, 0);
  }
  void add_bytesSent(uint64_t bytesSent) {
    fbb_.AddElement<uint64_t>(GetStatsResponse::VT_BYTESSENT, bytesSent, 0);
  }
  void add_bufferedAmount(uint32_t bufferedAmount) {
    fbb_.AddElement<uint32_t>(GetStatsResponse::VT_BUFFEREDAMOUNT, bufferedAmount, 0);
  }
  explicit GetStatsResponseBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<GetStatsResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<GetStatsResponse>(end);
    fbb_.Required(o, GetStatsResponse::VT_LABEL);
    fbb_.Required(o, GetStatsResponse::VT_PROTOCOL);
    return o;
  }
};

inline ::flatbuffers::Offset<GetStatsResponse> CreateGetStatsResponse(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t timestamp = 0,
    ::flatbuffers::Offset<::flatbuffers::String> label = 0,
    ::flatbuffers::Offset<::flatbuffers::String> protocol = 0,
    uint64_t messagesSent = 0,
    uint64_t bytesSent = 0,
    uint32_t bufferedAmount = 0) {
  GetStatsResponseBuilder builder_(_fbb);
  builder_.add_bytesSent(bytesSent);
  builder_.add_messagesSent(messagesSent);
  builder_.add_timestamp(timestamp);
  builder_.add_bufferedAmount(bufferedAmount);
  builder_.add_protocol(protocol);
  builder_.add_label(label);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<GetStatsResponse> CreateGetStatsResponseDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t timestamp = 0,
    const char *label = nullptr,
    const char *protocol = nullptr,
    uint64_t messagesSent = 0,
    uint64_t bytesSent = 0,
    uint32_t bufferedAmount = 0) {
  auto label__ = label ? _fbb.CreateString(label) : 0;
  auto protocol__ = protocol ? _fbb.CreateString(protocol) : 0;
  return FBS::DataConsumer::CreateGetStatsResponse(
      _fbb,
      timestamp,
      label__,
      protocol__,
      messagesSent,
      bytesSent,
      bufferedAmount);
}

struct SendRequest FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SendRequestBuilder Builder;
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return SendRequestTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PPID = 4,
    VT_DATA = 6
  };
  uint32_t ppid() const {
    return GetField<uint32_t>(VT_PPID, 0);
  }
  const ::flatbuffers::Vector<uint8_t> *data() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_DATA);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_PPID, 4) &&
           VerifyOffsetRequired(verifier, VT_DATA) &&
           verifier.VerifyVector(data()) &&
           verifier.EndTable();
  }
};

struct SendRequestBuilder {
  typedef SendRequest Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_ppid(uint32_t ppid) {
    fbb_.AddElement<uint32_t>(SendRequest::VT_PPID, ppid, 0);
  }
  void add_data(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> data) {
    fbb_.AddOffset(SendRequest::VT_DATA, data);
  }
  explicit SendRequestBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<SendRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<SendRequest>(end);
    fbb_.Required(o, SendRequest::VT_DATA);
    return o;
  }
};

inline ::flatbuffers::Offset<SendRequest> CreateSendRequest(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t ppid = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> data = 0) {
  SendRequestBuilder builder_(_fbb);
  builder_.add_data(data);
  builder_.add_ppid(ppid);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<SendRequest> CreateSendRequestDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t ppid = 0,
    const std::vector<uint8_t> *data = nullptr) {
  auto data__ = data ? _fbb.CreateVector<uint8_t>(*data) : 0;
  return FBS::DataConsumer::CreateSendRequest(
      _fbb,
      ppid,
      data__);
}

struct SetSubchannelsRequest FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SetSubchannelsRequestBuilder Builder;
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return SetSubchannelsRequestTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SUBCHANNELS = 4
  };
  const ::flatbuffers::Vector<uint16_t> *subchannels() const {
    return GetPointer<const ::flatbuffers::Vector<uint16_t> *>(VT_SUBCHANNELS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_SUBCHANNELS) &&
           verifier.VerifyVector(subchannels()) &&
           verifier.EndTable();
  }
};

struct SetSubchannelsRequestBuilder {
  typedef SetSubchannelsRequest Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_subchannels(::flatbuffers::Offset<::flatbuffers::Vector<uint16_t>> subchannels) {
    fbb_.AddOffset(SetSubchannelsRequest::VT_SUBCHANNELS, subchannels);
  }
  explicit SetSubchannelsRequestBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<SetSubchannelsRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<SetSubchannelsRequest>(end);
    fbb_.Required(o, SetSubchannelsRequest::VT_SUBCHANNELS);
    return o;
  }
};

inline ::flatbuffers::Offset<SetSubchannelsRequest> CreateSetSubchannelsRequest(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint16_t>> subchannels = 0) {
  SetSubchannelsRequestBuilder builder_(_fbb);
  builder_.add_subchannels(subchannels);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<SetSubchannelsRequest> CreateSetSubchannelsRequestDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint16_t> *subchannels = nullptr) {
  auto subchannels__ = subchannels ? _fbb.CreateVector<uint16_t>(*subchannels) : 0;
  return FBS::DataConsumer::CreateSetSubchannelsRequest(
      _fbb,
      subchannels__);
}

struct SetSubchannelsResponse FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SetSubchannelsResponseBuilder Builder;
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return SetSubchannelsResponseTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SUBCHANNELS = 4
  };
  const ::flatbuffers::Vector<uint16_t> *subchannels() const {
    return GetPointer<const ::flatbuffers::Vector<uint16_t> *>(VT_SUBCHANNELS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_SUBCHANNELS) &&
           verifier.VerifyVector(subchannels()) &&
           verifier.EndTable();
  }
};

struct SetSubchannelsResponseBuilder {
  typedef SetSubchannelsResponse Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_subchannels(::flatbuffers::Offset<::flatbuffers::Vector<uint16_t>> subchannels) {
    fbb_.AddOffset(SetSubchannelsResponse::VT_SUBCHANNELS, subchannels);
  }
  explicit SetSubchannelsResponseBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<SetSubchannelsResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<SetSubchannelsResponse>(end);
    fbb_.Required(o, SetSubchannelsResponse::VT_SUBCHANNELS);
    return o;
  }
};

inline ::flatbuffers::Offset<SetSubchannelsResponse> CreateSetSubchannelsResponse(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint16_t>> subchannels = 0) {
  SetSubchannelsResponseBuilder builder_(_fbb);
  builder_.add_subchannels(subchannels);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<SetSubchannelsResponse> CreateSetSubchannelsResponseDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint16_t> *subchannels = nullptr) {
  auto subchannels__ = subchannels ? _fbb.CreateVector<uint16_t>(*subchannels) : 0;
  return FBS::DataConsumer::CreateSetSubchannelsResponse(
      _fbb,
      subchannels__);
}

struct AddSubchannelRequest FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef AddSubchannelRequestBuilder Builder;
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return AddSubchannelRequestTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SUBCHANNEL = 4
  };
  uint16_t subchannel() const {
    return GetField<uint16_t>(VT_SUBCHANNEL, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, VT_SUBCHANNEL, 2) &&
           verifier.EndTable();
  }
};

struct AddSubchannelRequestBuilder {
  typedef AddSubchannelRequest Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_subchannel(uint16_t subchannel) {
    fbb_.AddElement<uint16_t>(AddSubchannelRequest::VT_SUBCHANNEL, subchannel, 0);
  }
  explicit AddSubchannelRequestBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<AddSubchannelRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<AddSubchannelRequest>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<AddSubchannelRequest> CreateAddSubchannelRequest(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t subchannel = 0) {
  AddSubchannelRequestBuilder builder_(_fbb);
  builder_.add_subchannel(subchannel);
  return builder_.Finish();
}

struct AddSubchannelResponse FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef AddSubchannelResponseBuilder Builder;
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return AddSubchannelResponseTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SUBCHANNELS = 4
  };
  const ::flatbuffers::Vector<uint16_t> *subchannels() const {
    return GetPointer<const ::flatbuffers::Vector<uint16_t> *>(VT_SUBCHANNELS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_SUBCHANNELS) &&
           verifier.VerifyVector(subchannels()) &&
           verifier.EndTable();
  }
};

struct AddSubchannelResponseBuilder {
  typedef AddSubchannelResponse Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_subchannels(::flatbuffers::Offset<::flatbuffers::Vector<uint16_t>> subchannels) {
    fbb_.AddOffset(AddSubchannelResponse::VT_SUBCHANNELS, subchannels);
  }
  explicit AddSubchannelResponseBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<AddSubchannelResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<AddSubchannelResponse>(end);
    fbb_.Required(o, AddSubchannelResponse::VT_SUBCHANNELS);
    return o;
  }
};

inline ::flatbuffers::Offset<AddSubchannelResponse> CreateAddSubchannelResponse(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint16_t>> subchannels = 0) {
  AddSubchannelResponseBuilder builder_(_fbb);
  builder_.add_subchannels(subchannels);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<AddSubchannelResponse> CreateAddSubchannelResponseDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint16_t> *subchannels = nullptr) {
  auto subchannels__ = subchannels ? _fbb.CreateVector<uint16_t>(*subchannels) : 0;
  return FBS::DataConsumer::CreateAddSubchannelResponse(
      _fbb,
      subchannels__);
}

struct RemoveSubchannelRequest FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef RemoveSubchannelRequestBuilder Builder;
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return RemoveSubchannelRequestTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SUBCHANNEL = 4
  };
  uint16_t subchannel() const {
    return GetField<uint16_t>(VT_SUBCHANNEL, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, VT_SUBCHANNEL, 2) &&
           verifier.EndTable();
  }
};

struct RemoveSubchannelRequestBuilder {
  typedef RemoveSubchannelRequest Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_subchannel(uint16_t subchannel) {
    fbb_.AddElement<uint16_t>(RemoveSubchannelRequest::VT_SUBCHANNEL, subchannel, 0);
  }
  explicit RemoveSubchannelRequestBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<RemoveSubchannelRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<RemoveSubchannelRequest>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<RemoveSubchannelRequest> CreateRemoveSubchannelRequest(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t subchannel = 0) {
  RemoveSubchannelRequestBuilder builder_(_fbb);
  builder_.add_subchannel(subchannel);
  return builder_.Finish();
}

struct RemoveSubchannelResponse FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef RemoveSubchannelResponseBuilder Builder;
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return RemoveSubchannelResponseTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SUBCHANNELS = 4
  };
  const ::flatbuffers::Vector<uint16_t> *subchannels() const {
    return GetPointer<const ::flatbuffers::Vector<uint16_t> *>(VT_SUBCHANNELS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_SUBCHANNELS) &&
           verifier.VerifyVector(subchannels()) &&
           verifier.EndTable();
  }
};

struct RemoveSubchannelResponseBuilder {
  typedef RemoveSubchannelResponse Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_subchannels(::flatbuffers::Offset<::flatbuffers::Vector<uint16_t>> subchannels) {
    fbb_.AddOffset(RemoveSubchannelResponse::VT_SUBCHANNELS, subchannels);
  }
  explicit RemoveSubchannelResponseBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<RemoveSubchannelResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<RemoveSubchannelResponse>(end);
    fbb_.Required(o, RemoveSubchannelResponse::VT_SUBCHANNELS);
    return o;
  }
};

inline ::flatbuffers::Offset<RemoveSubchannelResponse> CreateRemoveSubchannelResponse(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint16_t>> subchannels = 0) {
  RemoveSubchannelResponseBuilder builder_(_fbb);
  builder_.add_subchannels(subchannels);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<RemoveSubchannelResponse> CreateRemoveSubchannelResponseDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint16_t> *subchannels = nullptr) {
  auto subchannels__ = subchannels ? _fbb.CreateVector<uint16_t>(*subchannels) : 0;
  return FBS::DataConsumer::CreateRemoveSubchannelResponse(
      _fbb,
      subchannels__);
}

struct BufferedAmountLowNotification FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef BufferedAmountLowNotificationBuilder Builder;
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return BufferedAmountLowNotificationTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_BUFFEREDAMOUNT = 4
  };
  uint32_t bufferedAmount() const {
    return GetField<uint32_t>(VT_BUFFEREDAMOUNT, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_BUFFEREDAMOUNT, 4) &&
           verifier.EndTable();
  }
};

struct BufferedAmountLowNotificationBuilder {
  typedef BufferedAmountLowNotification Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_bufferedAmount(uint32_t bufferedAmount) {
    fbb_.AddElement<uint32_t>(BufferedAmountLowNotification::VT_BUFFEREDAMOUNT, bufferedAmount, 0);
  }
  explicit BufferedAmountLowNotificationBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<BufferedAmountLowNotification> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<BufferedAmountLowNotification>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<BufferedAmountLowNotification> CreateBufferedAmountLowNotification(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t bufferedAmount = 0) {
  BufferedAmountLowNotificationBuilder builder_(_fbb);
  builder_.add_bufferedAmount(bufferedAmount);
  return builder_.Finish();
}

struct MessageNotification FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef MessageNotificationBuilder Builder;
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return MessageNotificationTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PPID = 4,
    VT_DATA = 6
  };
  uint32_t ppid() const {
    return GetField<uint32_t>(VT_PPID, 0);
  }
  const ::flatbuffers::Vector<uint8_t> *data() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_DATA);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_PPID, 4) &&
           VerifyOffsetRequired(verifier, VT_DATA) &&
           verifier.VerifyVector(data()) &&
           verifier.EndTable();
  }
};

struct MessageNotificationBuilder {
  typedef MessageNotification Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_ppid(uint32_t ppid) {
    fbb_.AddElement<uint32_t>(MessageNotification::VT_PPID, ppid, 0);
  }
  void add_data(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> data) {
    fbb_.AddOffset(MessageNotification::VT_DATA, data);
  }
  explicit MessageNotificationBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<MessageNotification> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<MessageNotification>(end);
    fbb_.Required(o, MessageNotification::VT_DATA);
    return o;
  }
};

inline ::flatbuffers::Offset<MessageNotification> CreateMessageNotification(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t ppid = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> data = 0) {
  MessageNotificationBuilder builder_(_fbb);
  builder_.add_data(data);
  builder_.add_ppid(ppid);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<MessageNotification> CreateMessageNotificationDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t ppid = 0,
    const std::vector<uint8_t> *data = nullptr) {
  auto data__ = data ? _fbb.CreateVector<uint8_t>(*data) : 0;
  return FBS::DataConsumer::CreateMessageNotification(
      _fbb,
      ppid,
      data__);
}

inline const ::flatbuffers::TypeTable *GetBufferedAmountResponseTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_UINT, 0, -1 }
  };
  static const char * const names[] = {
    "bufferedAmount"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, nullptr, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *SetBufferedAmountLowThresholdRequestTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_UINT, 0, -1 }
  };
  static const char * const names[] = {
    "threshold"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, nullptr, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *DumpResponseTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_STRING, 0, -1 },
    { ::flatbuffers::ET_STRING, 0, -1 },
    { ::flatbuffers::ET_UCHAR, 0, 0 },
    { ::flatbuffers::ET_SEQUENCE, 0, 1 },
    { ::flatbuffers::ET_STRING, 0, -1 },
    { ::flatbuffers::ET_STRING, 0, -1 },
    { ::flatbuffers::ET_UINT, 0, -1 },
    { ::flatbuffers::ET_BOOL, 0, -1 },
    { ::flatbuffers::ET_BOOL, 0, -1 },
    { ::flatbuffers::ET_USHORT, 1, -1 }
  };
  static const ::flatbuffers::TypeFunction type_refs[] = {
    FBS::DataProducer::TypeTypeTable,
    FBS::SctpParameters::SctpStreamParametersTypeTable
  };
  static const char * const names[] = {
    "id",
    "dataProducerId",
    "type",
    "sctpStreamParameters",
    "label",
    "protocol",
    "bufferedAmountLowThreshold",
    "paused",
    "dataProducerPaused",
    "subchannels"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_TABLE, 10, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *GetStatsResponseTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_ULONG, 0, -1 },
    { ::flatbuffers::ET_STRING, 0, -1 },
    { ::flatbuffers::ET_STRING, 0, -1 },
    { ::flatbuffers::ET_ULONG, 0, -1 },
    { ::flatbuffers::ET_ULONG, 0, -1 },
    { ::flatbuffers::ET_UINT, 0, -1 }
  };
  static const char * const names[] = {
    "timestamp",
    "label",
    "protocol",
    "messagesSent",
    "bytesSent",
    "bufferedAmount"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_TABLE, 6, type_codes, nullptr, nullptr, nullptr, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *SendRequestTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_UINT, 0, -1 },
    { ::flatbuffers::ET_UCHAR, 1, -1 }
  };
  static const char * const names[] = {
    "ppid",
    "data"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_TABLE, 2, type_codes, nullptr, nullptr, nullptr, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *SetSubchannelsRequestTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_USHORT, 1, -1 }
  };
  static const char * const names[] = {
    "subchannels"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, nullptr, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *SetSubchannelsResponseTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_USHORT, 1, -1 }
  };
  static const char * const names[] = {
    "subchannels"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, nullptr, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *AddSubchannelRequestTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_USHORT, 0, -1 }
  };
  static const char * const names[] = {
    "subchannel"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, nullptr, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *AddSubchannelResponseTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_USHORT, 1, -1 }
  };
  static const char * const names[] = {
    "subchannels"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, nullptr, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *RemoveSubchannelRequestTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_USHORT, 0, -1 }
  };
  static const char * const names[] = {
    "subchannel"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, nullptr, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *RemoveSubchannelResponseTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_USHORT, 1, -1 }
  };
  static const char * const names[] = {
    "subchannels"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, nullptr, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *BufferedAmountLowNotificationTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_UINT, 0, -1 }
  };
  static const char * const names[] = {
    "bufferedAmount"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, nullptr, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *MessageNotificationTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_UINT, 0, -1 },
    { ::flatbuffers::ET_UCHAR, 1, -1 }
  };
  static const char * const names[] = {
    "ppid",
    "data"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_TABLE, 2, type_codes, nullptr, nullptr, nullptr, names
  };
  return &tt;
}

}  // namespace DataConsumer
}  // namespace FBS

#endif  // FLATBUFFERS_GENERATED_DATACONSUMER_FBS_DATACONSUMER_H_
